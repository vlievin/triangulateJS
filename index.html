<!DOCTYPE html PUBLIC>
<HTML>
   <HEAD>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>
   	<script type="text/javascript" src="//d3js.org/d3.v3.min.js"></script>
    <script type="text/javascript" src="jsfeat.js"></script>
   
    <link href="//getbootstrap.com/dist/css/bootstrap.min.css" rel="stylesheet">
    <style type="text/css">

      .sk-folding-cube {
  margin: 20px auto;
  width: 40px;
  height: 40px;
  position: relative;
  -webkit-transform: rotateZ(45deg);
          transform: rotateZ(45deg);
}

.sk-folding-cube .sk-cube {
  float: left;
  width: 50%;
  height: 50%;
  position: relative;
  -webkit-transform: scale(1.1);
      -ms-transform: scale(1.1);
          transform: scale(1.1); 
}
.sk-folding-cube .sk-cube:before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #333;
  -webkit-animation: sk-foldCubeAngle 2.4s infinite linear both;
          animation: sk-foldCubeAngle 2.4s infinite linear both;
  -webkit-transform-origin: 100% 100%;
      -ms-transform-origin: 100% 100%;
          transform-origin: 100% 100%;
}
.sk-folding-cube .sk-cube2 {
  -webkit-transform: scale(1.1) rotateZ(90deg);
          transform: scale(1.1) rotateZ(90deg);
}
.sk-folding-cube .sk-cube3 {
  -webkit-transform: scale(1.1) rotateZ(180deg);
          transform: scale(1.1) rotateZ(180deg);
}
.sk-folding-cube .sk-cube4 {
  -webkit-transform: scale(1.1) rotateZ(270deg);
          transform: scale(1.1) rotateZ(270deg);
}
.sk-folding-cube .sk-cube2:before {
  -webkit-animation-delay: 0.3s;
          animation-delay: 0.3s;
}
.sk-folding-cube .sk-cube3:before {
  -webkit-animation-delay: 0.6s;
          animation-delay: 0.6s; 
}
.sk-folding-cube .sk-cube4:before {
  -webkit-animation-delay: 0.9s;
          animation-delay: 0.9s;
}
@-webkit-keyframes sk-foldCubeAngle {
  0%, 10% {
    -webkit-transform: perspective(140px) rotateX(-180deg);
            transform: perspective(140px) rotateX(-180deg);
    opacity: 0; 
  } 25%, 75% {
    -webkit-transform: perspective(140px) rotateX(0deg);
            transform: perspective(140px) rotateX(0deg);
    opacity: 1; 
  } 90%, 100% {
    -webkit-transform: perspective(140px) rotateY(180deg);
            transform: perspective(140px) rotateY(180deg);
    opacity: 0; 
  } 
}

@keyframes sk-foldCubeAngle {
  0%, 10% {
    -webkit-transform: perspective(140px) rotateX(-180deg);
            transform: perspective(140px) rotateX(-180deg);
    opacity: 0; 
  } 25%, 75% {
    -webkit-transform: perspective(140px) rotateX(0deg);
            transform: perspective(140px) rotateX(0deg);
    opacity: 1; 
  } 90%, 100% {
    -webkit-transform: perspective(140px) rotateY(180deg);
            transform: perspective(140px) rotateY(180deg);
    opacity: 0; 
  }
}


      

    </style>

      <TITLE>
         Triangulr
      </TITLE>
   </HEAD>
<BODY>

<input type="file" id="imageLoader" name="imageLoader"/>
<div id="loading_animation" >
  <div class="sk-folding-cube">
    <div class="sk-cube1 sk-cube"></div>
    <div class="sk-cube2 sk-cube"></div>
    <div class="sk-cube4 sk-cube"></div>
    <div class="sk-cube3 sk-cube"></div>
  </div>
  <div style = "text-align:center;">
    <p>Please wait :)</p>
    <br>
    <p>The process can take up to 5min...</p>
  </div>
</div>

<canvas id="canvas" width="600" height="600" style="float:left; visibility:hidden;"></canvas>
<!-- <div id="color" style="width:200px;height:50px;float:left"></div> -->
<div id="area"></div>
<canvas id="edges_canvas" width="600" height="600" style="float:left; visibility:hidden;"></canvas>
<canvas id="forbidden_canvas" width="600" height="600" style="float:left; visibility:hidden;"></canvas>
<script type="text/javascript">

$("#loading_animation").hide();

var imageLoader = document.getElementById('imageLoader');
    imageLoader.addEventListener('change', handleImage, false);

var img = new Image();

function handleImage(e){
    $("#loading_animation").show(); 
    var reader = new FileReader();
    reader.onload = function(event){
        img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);     
}  

//var img = new Image();
//img.src = 'flower.jpg';
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

r_edges = 5
r_stroke = 3
var forbidden_values = new Array();
  for (var i = 0 ; i <canvas.width; i++)
  {
    forbidden_values[i] = []
    for (var j = 0; j < canvas.height ; j++)
    {
     forbidden_values[i][j] = 0;
    }
}

function drawForbidden(x,y, forbidden_values)
{
  var d = Math.floor(r_edges/2) + 1
  for (var i = x - d ; i <= x + d ; i++)
  {
    for (var j = y - d ; j <= y + d ; j++)
    {
      if (i >= 0 && j >= 0 && i < canvas.width && j <  canvas.height )
      {
        forbidden_values[ i ][ j ] = 100;
      }

    }
  }
}

var NUMBER_OF_POINTS = 200;
// create svg variable
var svg = d3.select("#area").append("svg")
    				.attr("width", canvas.width)
    				.attr("height", canvas.height);


img.onload = function () {


    /// set size proportional to image
    canvas.height = canvas.width * (img.height / img.width);
    /// step 1 - resize to 50%
    var oc = document.createElement('canvas'),
        octx = oc.getContext('2d');

    oc.width = img.width * 0.5;
    oc.height = img.height * 0.5;
    octx.drawImage(img, 0, 0, oc.width, oc.height);
    /// step 2 - resize 50% of step 1
    octx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5);
    /// step 3, resize to final size
    ctx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5,
    0, 0, canvas.width, canvas.height);
    /* RESIZED */

    points = []
    points.push([ 0 , 0]);
    points.push([ 0 , canvas.height]);
    points.push([ canvas.width , 0]);
    points.push([ canvas.width , canvas.height]);
    var ptsides = Math.sqrt(NUMBER_OF_POINTS);
    for ( i = 0; i < ptsides ; i ++)
    {

      points.push( [  0 , Math.floor(Math.random() * canvas.height) ] );
      points.push( [  canvas.width , Math.floor(Math.random() * canvas.height) ] );
      points.push( [  Math.floor(Math.random() * canvas.width) , 0 ] );
      points.push( [  Math.floor(Math.random() * canvas.width) , canvas.height ] );
    }
    for ( i = 0; i < NUMBER_OF_POINTS ; i ++)
    {
    	var x = Math.floor(Math.random() * canvas.width);
    	var y = Math.floor(Math.random() * canvas.height);
		  points.push( [ x , y ] );

      //forbidden_canvas_ctx.arc(x, y, r_edges, 0, 2*Math.PI, true);
      /*var circle = new Path2D();
      circle.arc(x, y, r_edges, 0, 2 * Math.PI);*/
      //forbidden_canvas_ctx.fill(circle);

    }
    for (var k = 0 ; k < points.length ; k ++)
      drawForbidden(points[k][0],points[k][1], forbidden_values);

    /* EDGES DETECTION */
    img_u8 = new jsfeat.matrix_t(canvas.width, canvas.height, jsfeat.U8C1_t);
    
    var edges_canvas = document.getElementById('edges_canvas');
    var edges_ctx = edges_canvas.getContext('2d');
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, img_u8);

    var r = 2
    var kernel_size = (r+1) << 1;

    jsfeat.imgproc.gaussian_blur(img_u8, img_u8, kernel_size, 0);

    jsfeat.imgproc.canny(img_u8, img_u8, 30, 158);

    var data_u32 = new Uint32Array(imageData.data.buffer);
    var alpha = (0xff << 24);
    var i = img_u8.cols*img_u8.rows, pix = 0;
    while(--i >= 0) {
        pix = img_u8.data[i];
        data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
    }

    edges_ctx.putImageData(imageData, 0, 0);

      console.log(".. contour points");
      /* ADD POINTS AROUND EDGES */
      for (i = 0; i < oc.width; i++) // oc.width
      {
        for (j=0; j < oc.height; j++) // oc.height
        {
           var pixel = edges_ctx.getImageData(i, j, 1, 1);
           var data = pixel.data; 
           if (data[0] > 0 )
           {  
              var d = r_stroke/2;
              var x = Math.floor(i - d + Math.random() * r_stroke );
              var y = Math.floor(j - d + Math.random() * r_stroke );
              if (x >= 0 && y >= 0 && x < canvas.width && y <  canvas.height )
              {
                if (forbidden_values[ x ][ y ] == 0 )
                {
                  points.push([x,y])
                  drawForbidden(x,y, forbidden_values);
                }
              }
              
              
           }

        }
      }


      /*var forb = document.getElementById('forbidden_canvas');
      var ctx_forb = forb.getContext('2d');
      for (var i = 0 ; i <canvas.width; i++)
      {
        for (var j = 0; j < canvas.height ; j++)
        {
         if (forbidden_values[i][j] > 1)
         {
            var circle = new Path2D();
            circle.arc(i, j, 5, 0, 2 * Math.PI);
            ctx_forb.fill(circle);
         }
        }
    }*/



      /* POINTS CREATED */
    var delaunay = d3.geom.delaunay(points);


    path = svg.append("g")
      .selectAll("path");
      
      path = path.data(delaunay);
        
    path.enter().append("path")
        .attr("d", function(d) { return "M" + d.join("L") + "Z"; })
              .style('fill', function(d, i) {
              var x = (parseFloat(d[0][0]) + parseFloat(d[1][0]) + parseFloat(d[2][0]))/3;
              var y = (parseFloat(d[0][1]) + parseFloat(d[1][1]) + parseFloat(d[2][1]))/3;
              return getColor(x, y);
                
              })
              .style('stroke', function(d, i) {
              var x = (parseFloat(d[0][0]) + parseFloat(d[1][0]) + parseFloat(d[2][0]))/3;
              var y = (parseFloat(d[0][1]) + parseFloat(d[1][1]) + parseFloat(d[2][1]))/3;
              return getColor(x, y);
                
              })
              .style("stroke-width" , 1);

    console.log(points.length);
    /*for (i = 0 ; i < points.length ; i++ )
    {
        var circle = svg.append("circle")
                .attr("cx", points[i][0])
                .attr("cy", points[i][1])
                .attr("r", 3)
                .attr("fill", "black");
    }*/


    $("#loading_animation").hide();
    

}

// get color based on center
function getColor(x, y) {
        var pixel = ctx.getImageData(x, y, 1, 1);
	    var data = pixel.data;
	    var rgba = 'rgba(' + data[0] + ',' + data[1] +
	             ',' + data[2] + ',' + data[3] + ')';

		return rgba
      }


var color = document.getElementById('color');
function pick(event) {
  var x = event.layerX;
  var y = event.layerY;
  var pixel = ctx.getImageData(x, y, 1, 1);
  var data = pixel.data;
  var rgba = 'rgba(' + data[0] + ',' + data[1] +
             ',' + data[2] + ',' + data[3] + ')';
  color.style.background =  rgba;
  color.textContent = rgba;
}
// canvas.addEventListener('mousemove', pick);


</script>
</BODY>
</HTML>