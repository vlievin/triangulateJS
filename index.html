<!DOCTYPE html PUBLIC>
<HTML>
   <HEAD>
   	<script type="text/javascript" src="//d3js.org/d3.v3.min.js"></script>
    <script type="text/javascript" src="jsfeat.js"></script>
    <script type="text/javascript" src="delaunay.js"></script>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">

    <!-- jQuery library -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.0/jquery.min.js"></script>

    <!-- Latest compiled JavaScript -->
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <style type="text/css">

    body {
    background-color: #eee;
    }

    .row {
      background-color: #fff;
      padding: 20px;
      }
      .box-shadow--2dp {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12)
      }
      .box-shadow--3dp {
        box-shadow: 0 3px 4px 0 rgba(0, 0, 0, .14), 0 3px 3px -2px rgba(0, 0, 0, .2), 0 1px 8px 0 rgba(0, 0, 0, .12)
      }
      .box-shadow--4dp {
        box-shadow: 0 4px 5px 0 rgba(0, 0, 0, .14), 0 1px 10px 0 rgba(0, 0, 0, .12), 0 2px 4px -1px rgba(0, 0, 0, .2)
      }
      .box-shadow--6dp {
        box-shadow: 0 6px 10px 0 rgba(0, 0, 0, .14), 0 1px 18px 0 rgba(0, 0, 0, .12), 0 3px 5px -1px rgba(0, 0, 0, .2)
      }
      .box-shadow--8dp {
        box-shadow: 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12), 0 5px 5px -3px rgba(0, 0, 0, .2)
      }
      .box-shadow--16dp {
        box-shadow: 0 16px 24px 2px rgba(0, 0, 0, .14), 0 6px 30px 5px rgba(0, 0, 0, .12), 0 8px 10px -5px rgba(0, 0, 0, .2)
      }
      .top-buffer { margin-top:5px; }

            .sk-folding-cube {
        margin: 20px auto;
        width: 40px;
        height: 40px;
        position: relative;
        -webkit-transform: rotateZ(45deg);
                transform: rotateZ(45deg);
      }

      .sk-folding-cube .sk-cube {
        float: left;
        width: 50%;
        height: 50%;
        position: relative;
        -webkit-transform: scale(1.1);
            -ms-transform: scale(1.1);
                transform: scale(1.1); 
      }
      .sk-folding-cube .sk-cube:before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #333;
        -webkit-animation: sk-foldCubeAngle 2.4s infinite linear both;
                animation: sk-foldCubeAngle 2.4s infinite linear both;
        -webkit-transform-origin: 100% 100%;
            -ms-transform-origin: 100% 100%;
                transform-origin: 100% 100%;
      }
      .sk-folding-cube .sk-cube2 {
        -webkit-transform: scale(1.1) rotateZ(90deg);
                transform: scale(1.1) rotateZ(90deg);
      }
      .sk-folding-cube .sk-cube3 {
        -webkit-transform: scale(1.1) rotateZ(180deg);
                transform: scale(1.1) rotateZ(180deg);
      }
      .sk-folding-cube .sk-cube4 {
        -webkit-transform: scale(1.1) rotateZ(270deg);
                transform: scale(1.1) rotateZ(270deg);
      }
      .sk-folding-cube .sk-cube2:before {
        -webkit-animation-delay: 0.3s;
                animation-delay: 0.3s;
      }
      .sk-folding-cube .sk-cube3:before {
        -webkit-animation-delay: 0.6s;
                animation-delay: 0.6s; 
      }
      .sk-folding-cube .sk-cube4:before {
        -webkit-animation-delay: 0.9s;
                animation-delay: 0.9s;
      }
      @-webkit-keyframes sk-foldCubeAngle {
        0%, 10% {
          -webkit-transform: perspective(140px) rotateX(-180deg);
                  transform: perspective(140px) rotateX(-180deg);
          opacity: 0; 
        } 25%, 75% {
          -webkit-transform: perspective(140px) rotateX(0deg);
                  transform: perspective(140px) rotateX(0deg);
          opacity: 1; 
        } 90%, 100% {
          -webkit-transform: perspective(140px) rotateY(180deg);
                  transform: perspective(140px) rotateY(180deg);
          opacity: 0; 
        } 
      }

      @keyframes sk-foldCubeAngle {
        0%, 10% {
          -webkit-transform: perspective(140px) rotateX(-180deg);
                  transform: perspective(140px) rotateX(-180deg);
          opacity: 0; 
        } 25%, 75% {
          -webkit-transform: perspective(140px) rotateX(0deg);
                  transform: perspective(140px) rotateX(0deg);
          opacity: 1; 
        } 90%, 100% {
          -webkit-transform: perspective(140px) rotateY(180deg);
                  transform: perspective(140px) rotateY(180deg);
          opacity: 0; 
        }
      }
    </style>

      <TITLE>
         TriangulateJS
      </TITLE>
   </HEAD>
<BODY>

  <nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" href="#">TriangulateJS</a>
    </div>
    <!-- <ul class="nav navbar-nav">
      <li class="active"><a href="#">Home</a></li>
      <li><a href="#">Page 1</a></li>
      <li><a href="#">Page 2</a></li> 
      <li><a href="#">Page 3</a></li> 
    </ul> -->
  </div>
</nav>

<div class  = "constainer" >
  <div class="row box-shadow--2dp" style="width : 300px; margin: 0 auto; ">
    <p>Transform your file into polygon art</p>
    <input type="file" id="imageLoader" name="imageLoader" accept="image/*"/>
    <a id="download">Download as image</a>
  </div>
  <div id="loading_animation" >
    <div class="sk-folding-cube">
      <div class="sk-cube1 sk-cube"></div>
      <div class="sk-cube2 sk-cube"></div>
      <div class="sk-cube4 sk-cube"></div>
      <div class="sk-cube3 sk-cube"></div>
    </div>
    <div style = "text-align:center;">
      <p>Please wait :)</p>
      <br>
      <p>It shouldn't take long...</p>
    </div>
  </div>

  <div style = "text-align:center; margin-top: 20px;">
    <div id="resultContainer" class="row row box-shadow--2dp" style="text-align:center; display: inline-block">
      <div id="area"></div>
      <canvas id="canvas_result" width="600" height="600" ></canvas>
    </div>
  </div>
</div>


<canvas id="canvas" width="600" height="600" style="float:left; visibility:hidden;"></canvas>
<canvas id="canvas_result" width="600" height="600" ></canvas>


</div>

<script type="text/javascript">

$("#loading_animation").hide();
$("#resultContainer").hide();
$("#download").hide();

var imageLoader = document.getElementById('imageLoader');
    imageLoader.addEventListener('change', handleImage, false);

var img = new Image();

function handleImage(e){
    $("#loading_animation").show(); 
    var reader = new FileReader();
    reader.onload = function(event){
      $("#loading_animation").show(); 
        img.src = event.target.result;
    }
    reader.readAsDataURL(e.target.files[0]);     
}  

//var img = new Image();
//img.src = 'flower.jpg';

var r_edges = 5
var r_stroke = 3
var NUMBER_OF_POINTS = 200;
var factor_size = 1.5;
var can1 = 20;
var can2 = 70;


var forbidden_values = new Array();
  for (var i = 0 ; i <canvas.width; i++)
  {
    forbidden_values[i] = []
    for (var j = 0; j < canvas.height ; j++)
    {
     forbidden_values[i][j] = 0;
    }
}

function drawForbidden(x,y, forbidden_values)
{
  var d = Math.floor(r_edges/2) + 1
  for (var i = x - d ; i <= x + d ; i++)
  {
    for (var j = y - d ; j <= y + d ; j++)
    {
      if (i >= 0 && j >= 0 && i < canvas.width && j <  canvas.height )
      {
        forbidden_values[ i ][ j ] = 100;
      }
    }
  }
}


img.onload = function () {
    $("#resultContainer").hide();
    console.log("onLoad...");

    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    canvas.width = 600;
    canvas.height = 600;

    // get color based on center
    function getColor(x, y) {
            var pixel = ctx.getImageData(x, y, 1, 1);
          var data = pixel.data;
          var rgba = 'rgba(' + data[0] + ',' + data[1] +
                   ',' + data[2] + ',' + data[3] + ')';
        return rgba
          }

    /// set size proportional to image
    tmp = canvas.width * (img.height / img.width);
    if (tmp > canvas.height)
    {
      k = canvas.height / tmp;
      canvas.width *= k;
    }
    else
    {
      canvas.height = tmp;
    }

    // create svg variable
    /*d3.select("svg").remove();
    var svg = d3.select("#area").append("svg")
                .attr("width", canvas.width * factor_size)
                .attr("height", canvas.height * factor_size);*/


    /// step 1 - resize to 50%
    var oc = document.createElement('canvas'),
        octx = oc.getContext('2d');

    oc.width = img.width * 0.5;
    oc.height = img.height * 0.5;
    octx.drawImage(img, 0, 0, oc.width, oc.height);
    /// step 2 - resize 50% of step 1
    octx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5);
    /// step 3, resize to final size
    ctx.drawImage(oc, 0, 0, oc.width * 0.5, oc.height * 0.5,
    0, 0, canvas.width, canvas.height);
    /* RESIZED */

    console.log("add random points...");
    points = []
    points.push([ 0 , 0]);
    points.push([ 0 , canvas.height]);
    points.push([ canvas.width , 0]);
    points.push([ canvas.width , canvas.height]);
    var ptsides = Math.sqrt(NUMBER_OF_POINTS);
    for ( i = 0; i < ptsides ; i ++)
    {

      points.push( [  0 , Math.floor(Math.random() * canvas.height) ] );
      points.push( [  canvas.width , Math.floor(Math.random() * canvas.height) ] );
      points.push( [  Math.floor(Math.random() * canvas.width) , 0 ] );
      points.push( [  Math.floor(Math.random() * canvas.width) , canvas.height ] );
    }
    for ( i = 0; i < NUMBER_OF_POINTS ; i ++)
    {
    	var x = Math.floor(Math.random() * canvas.width);
    	var y = Math.floor(Math.random() * canvas.height);
		  points.push( [ x , y ] );

      //forbidden_canvas_ctx.arc(x, y, r_edges, 0, 2*Math.PI, true);
      /*var circle = new Path2D();
      circle.arc(x, y, r_edges, 0, 2 * Math.PI);*/
      //forbidden_canvas_ctx.fill(circle);

    }
    for (var k = 0 ; k < points.length ; k ++)
      drawForbidden(points[k][0],points[k][1], forbidden_values);

    /* EDGES DETECTION */
    console.log("edges Detection...");
    img_u8 = new jsfeat.matrix_t(canvas.width, canvas.height, jsfeat.U8C1_t);
    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

    jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, img_u8);

    var r = 2
    var kernel_size = (r+1) << 1;

    jsfeat.imgproc.gaussian_blur(img_u8, img_u8, kernel_size, 0);

    jsfeat.imgproc.canny(img_u8, img_u8, can1, can2);

      /* ADD POINTS AROUND EDGES */

      test = []
      var n = img_u8.cols*img_u8.rows;
      for (i = 0; i < img_u8.cols; i++) // oc.width
      {
        for (j=0; j < img_u8.rows; j++) // oc.height
        {
           k = (j * img_u8.cols + i );
           pix = img_u8.data[k];
           var d = (pix << 8) | pix;
           if ( d > 0 )
           {  
              if (Math.random() < 0.9)
              {
                rr = r_stroke;
              }
              else
              {
                rr = 4 * r_stroke;
              }
              test.push(d)
              var d = rr/2;
              var x = Math.floor(i - d + Math.random() * rr );
              var y = Math.floor(j - d + Math.random() * rr );
              if (x >= 0 && y >= 0 && x < canvas.width && y <  canvas.height )
              {
                if (forbidden_values[ x ][ y ] == 0 )
                {
                  points.push([x,y])
                  drawForbidden(x,y, forbidden_values);
                }
              }
              
              
           }

        }
      }

      //console.log(ref.length);
      //console.log(test.length);


      /*var forb = document.getElementById('forbidden_canvas');
      var ctx_forb = forb.getContext('2d');
      for (var i = 0 ; i <canvas.width; i++)
      {
        for (var j = 0; j < canvas.height ; j++)
        {
         if (forbidden_values[i][j] > 1)
         {
            var circle = new Path2D();
            circle.arc(i, j, 5, 0, 2 * Math.PI);
            ctx_forb.fill(circle);
         }
        }
    }*/



      /* POINTS CREATED */

      /*translates points : factor size*/
      for (var i = 0 ; i < points.length ; i++)
        points[i] = [ factor_size * points[i][0] , factor_size * points[i][1] ];

    console.log("compute delaunay triangulation...");

    var canvas_result = document.getElementById('canvas_result');
    canvas_result.height = canvas.height * factor_size;
    canvas_result.width = canvas.width * factor_size;
    var ctx_result = canvas_result.getContext('2d');

    tris = Delaunay.triangulate( points );
    for ( var k = 0 ; k < tris.length ; k += 3 )
    {
      var a = points[  tris[k] ];
      var b = points[  tris[k + 1] ];
      var c = points[  tris[k + 2] ];
      //centroid
      var x = (parseFloat(a[0]) + parseFloat(b[0]) + parseFloat(c[0]))/ ( 3 * factor_size);
      var y = (parseFloat(a[1]) + parseFloat(b[1]) + parseFloat(c[1]))/ ( 3 * factor_size);
      color =  getColor(x, y)

      ctx_result.fillStyle = color;
      ctx_result.strokeStyle = color;
      ctx_result.beginPath();
      ctx_result.moveTo(a[0],a[1]);
      ctx_result.lineTo(b[0],b[1]);
      ctx_result.lineTo(c[0],c[1]);
      ctx_result.closePath();
      ctx_result.fill();
      ctx_result.stroke();

    }
    

    /*console.log("compute d3 delaunay triangulation...");
    var delaunayd3 = d3.geom.delaunay(points);


    path = svg.append("g")
      .selectAll("path");
      
      path = path.data(delaunayd3);
    
    console.log("draw polygons...");
    path.enter().append("path")
        .attr("d", function(d) { return "M" + d.join("L") + "Z"; })
              .style('fill', function(d, i) {
              var x = (parseFloat(d[0][0]) + parseFloat(d[1][0]) + parseFloat(d[2][0]))/ ( 3 * factor_size);
              var y = (parseFloat(d[0][1]) + parseFloat(d[1][1]) + parseFloat(d[2][1]))/ ( 3 * factor_size);
              return getColor(x, y);
              })
             .style('stroke', function(d, i) {
              var x = (parseFloat(d[0][0]) + parseFloat(d[1][0]) + parseFloat(d[2][0]))/ ( 3 * factor_size);
              var y = (parseFloat(d[0][1]) + parseFloat(d[1][1]) + parseFloat(d[2][1]))/ ( 3 * factor_size);
              return getColor(x, y);
                
              })
              //.style('stroke', "white")
              .style("stroke-width" , 1);

          */

    /*for (i = 0 ; i < points.length ; i++ )
    {
        var circle = svg.append("circle")
                .attr("cx", points[i][0])
                .attr("cy", points[i][1])
                .attr("r", 3)
                .attr("fill", "black");
    }*/

    console.log("done!");
    $("#loading_animation").hide();
    $("#resultContainer").show();
    $("#download").show();
    $("#imageLoader").hide();
    

}


var color = document.getElementById('color');
function pick(event) {
  var x = event.layerX;
  var y = event.layerY;
  var pixel = ctx.getImageData(x, y, 1, 1);
  var data = pixel.data;
  var rgba = 'rgba(' + data[0] + ',' + data[1] +
             ',' + data[2] + ',' + data[3] + ')';
  color.style.background =  rgba;
  color.textContent = rgba;
}
// canvas.addEventListener('mousemove', pick);


/**
 * This is the function that will take care of image extracting and
 * setting proper filename for the download.
 * IMPORTANT: Call it from within a onclick event.
*/
function downloadCanvas(link, canvasId, filename) {
    link.href = document.getElementById(canvasId).toDataURL();
    link.download = filename;
}

/** 
 * The event handler for the link's onclick event. We give THIS as a
 * parameter (=the link element), ID of the canvas and a filename.
*/
document.getElementById('download').addEventListener('click', function() {
    downloadCanvas(this, 'canvas_result', 'yourAmazingPolygonArt.png');
}, false);


</script>
</BODY>
</HTML>